---
title: "Single-cell RNA-seq data analysis"
author: "Dresden-concept Genome Center, TU Dresden"
date: "May 2020"
geometry: margin=2cm
bibliography: "references.bib"
output:
   html_document:
    toc: true
    highlight: tango
    theme: paper
    code_folding: hide
---

```{r setup, warning=FALSE, message=FALSE}
# R Options
options(stringsAsFactors=FALSE, "citation_format"="pandoc")

# Required libraries
library(Seurat) # main
library(ggplot2) # plots
library(patchwork) # combination of plots
library(magrittr) # %>% operator
library(reticulate) # required for 'leiden' clustering
library(enrichR) # functional enrichment
library(future) # multicore support for Seurat
plan("multiprocess") # by default, this uses all available cores; use "workers=4" for example, to use 4 cores
options(future.globals.maxSize = 800000000) # increase if the maximum allowed size of objects exported by future is exceeded

# Other libraries we use
# Knit: knitr
# Data handling: dplyr, tidyr, purrr
# Tables: kableExtra
# Plots: ggsci, ggpubr
# IO: openxlsx
# Annotation: biomaRt
# DEG: mast
# Functional enrichment: enrichR

# Source plotting functions
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")
source("R/functions_util.R")

# Knitr default options
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, message=FALSE, warning=FALSE, fig.width=10)

# Potentially needed for clustering, umap, other python packages
use_python('/usr/bin/python')

# biomaRt mirror
mirror = NULL



```

# Dataset description
* 10X published dataset, downloaded from [here](https://support.10xgenomics.com/single-cell-gene-expression/datasets/3.0.0/pbmc_1k_v3) 
* Single Cell Gene Expression Dataset by Cell Ranger 3.0.0  
* 1k Peripheral blood mononuclear cells (PBMCs) from a healthy donor (v3 chemistry)  

## Project-specific parameters
This code chunk contains all parameters that are set specifically for your project. 
```{r project_parameters, class.source='fold-show'}
param = list()

# Project ID
param$project = "pbmc"

# Input data path in case Cell Ranger was run 
param$path_data = data.frame(name=c("set1","set2"),
                             type=c("10x","smartseq2"),
                             path=c("test_datasets/10x_SmartSeq2_pbmc_GSE132044/counts/10x/","test_datasets/10x_SmartSeq2_pbmc_GSE132044/counts/smartseq2/counts_table.tsv.gz"))
param$file_mapping_stats = NULL

# Project-specific paths
param$path_out = "test_datasets/10x_SmartSeq2_pbmc_GSE132044/results/"
if (!file.exists(param$path_out)) dir.create(param$path_out, recursive=TRUE)

# Annotation via biomaRt
param$mart_dataset = "hsapiens_gene_ensembl"
param$file_annot = NULL
if (is.null(param$file_annot)) {
  param$file_annot = file.path(param$path_out, paste0(param$mart_dataset, ".annot.csv"))
}
param$mart_attributes = c("ensembl_gene_id", "external_gene_name", "hgnc_symbol", "entrezgene_accession", "chromosome_name", "start_position", "end_position", "percentage_gene_gc_content", "gene_biotype", "strand", "description")

# Prefix of mitochondrial genes 
param$mt = "^MT-"

# Filters
param$cell_filter = list(nFeature_RNA=c(200,NA), percent_mt=c(NA,20))
param$features_filter = list(min_counts=1, min_cells=1) # feature has to be found by at least one count in one cell
param$samples_to_drop = c("NC", "RNA") # cells from these samples will be dropped after initial QC

# Whether or not to remove cell cycle effects
param$cc_remove = FALSE

# Should all cell cycle effects be removed, or only the difference between profilerating cells (G2M and S phase)?
# Read https://satijalab.org/seurat/v3.1/cell_cycle_vignette.html, for an explanation
param$cc_remove_all = FALSE

# Additional variables to regress out
param$vars_to_regress = c()

# Additional variables to include as covariates
param$latent_vars = c()

# When there are multiple datasets, how to integrate them:
#   - method:
#     - merge: Just merge them since no integration is needed (e.g. samples were multiplexed on the same chip)
#     - standard: Anchors are computed for all pairs of datasets. This will give all datasets the same weight during dataset integration but can be computationally intensive.
#     - reference: One dataset is used as reference and anchors are computed for all other datasets. Less accurate but computationally faster. 
#     - reciprocal: Anchors are computed in PCA space instead of the data. Even less accurate but for very big datasets.
#   - reference_dataset: When using method "reference", which dataset is the reference? Can be numeric or name of the dataset.
param$integrate_samples = list(method="standard", reference_dataset=1, dimensions=30)

# The number of PCs to use; adjust this parameter based on JackStraw and Elbowplot 
param$pc_n = 10

# Resolution of clusters; low values will lead to fewer clusters of cells 
param$cluster_resolution=0.5

# Thresholds to define differentially expressed genes 
param$padj = 0.05
param$log2fc = log2(1.5)

# Marker genes based on literature 
# https://icb-scanpy-tutorials.readthedocs-hosted.com/en/latest/visualizing-marker-genes.html
param$known_markers = list()
param$known_markers[["bcell"]] = c("CD79A", "MS4A1")
param$known_markers[["tcell"]] = "CD3D"
param$known_markers[["tcell.cd8+"]] = c("CD8A", "CD8B")
param$known_markers[["nk"]] = c("GNLY", "NKG7")
param$known_markers[["myeloid"]] = c("CST3", "LYZ")
param$known_markers[["monocytes"]] = "FCGR3A"
param$known_markers[["dendritic"]] = "FCER1A"

# Enrichr databases of interest
param$enrichr_dbs = c("GO_Molecular_Function_2018", "GO_Biological_Process_2018", "GO_Cellular_Component_2018")

# Main colour(s) to use for plots
param$col = "palevioletred"

# Colour palette and colours used for samples
param$col_palette_samples = ggsci::pal_npg
```

# Read data
## Read and print mapping statistics
We begin by printing mapping statistics that have been produced prior to this workflow. 
```{r mapping_stats}
if (!is.null(param$file_mapping_stats)) {
  mapping_stats = as.data.frame(t(read.delim(param$file_mapping_stats, sep=",", header=TRUE, check.names=FALSE)))
  colnames(mapping_stats) = "Value"
  knitr::kable(mapping_stats, align="l", caption="Mapping statistics") %>% 
    kableExtra::kable_styling(bootstrap_options=c("striped", "hover"))
 
} else { 
  message("Mapping statistics cannot be shown. No valid file provided.")
}
```

## Read gene annotation
We read gene annotation from Ensembl, and translate Ensembl IDs to Entrez gene symbols. The resulting table is written to file. 
```{r read_annotation}
# Read annotation from csv or from Ensembl and a tab separated csv will be created
if (file.exists(param$file_annot)) {
  annot_ensembl = read.delim(param$file_annot)
  
  # Double-check whether all required columns are included
  if (any(!c("ensembl_gene_id", "external_gene_name","entrezgene_accession") %in% colnames(annot_ensembl))) {
    stop("The annotation table misses at least one of the following columns: 'ensembl_gene_id', 'external_gene_name','entrezgene_accession'.")
  }
} else {
  mart_attributes = unique(c("ensembl_gene_id", "external_gene_name","entrezgene_accession", param$mart_attributes))
  annot_mart = biomaRt::useEnsembl("ensembl", dataset=param$mart_dataset, mirror=mirror)
  annot_ensembl = biomaRt::getBM(mart=annot_mart, attributes=mart_attributes)
  write.table(annot_ensembl, file=param$file_annot, sep='\t', col.names=TRUE, row.names=FALSE, append=FALSE)
  message("Gene annotation file was created at: ", param$file_annot)
  # Note: depending on the attributes, there might be more than one row per gene
}

# Create translation tables
# Ensembl id to gene symbol
ensembl_to_symbol = unique(annot_ensembl[,c("ensembl_gene_id","external_gene_name")])
ensembl_to_symbol = setNames(ensembl_to_symbol$external_gene_name, ensembl_to_symbol$ensembl_gene_id)

# Ensembl id to seurat-compatible unique rowname
ensembl_to_seurat_rowname = unique(annot_ensembl[,c("ensembl_gene_id", "external_gene_name")])
ensembl_to_seurat_rowname$external_gene_name = make.unique(gsub(pattern="_", replacement="-", x=ensembl_to_seurat_rowname$external_gene_name, fixed=T))
ensembl_to_seurat_rowname = setNames(ensembl_to_seurat_rowname$external_gene_name, ensembl_to_seurat_rowname$ensembl_gene_id)

# Seurat-compatible unique rowname to ensembl id
seurat_rowname_to_ensembl = setNames(names(ensembl_to_seurat_rowname), ensembl_to_seurat_rowname)

# Gene symbol to ensembl id: named LIST to account for genes where one symbol translates to multiple Ensembl IDs
symbol_to_ensembl_df = unique(annot_ensembl[,c("ensembl_gene_id","external_gene_name")])
symbol_to_ensembl = split(symbol_to_ensembl_df$ensembl_gene_id, symbol_to_ensembl_df$external_gene_name)

# Gene symbol to (seurat compatible unique) gene symbol: named LIST to account for genes with multiple names
symbol_to_seurat_rowname = unique(annot_ensembl[,c("ensembl_gene_id","external_gene_name")])
symbol_to_seurat_rowname$seurat_rowname = ensembl_to_seurat_rowname[symbol_to_seurat_rowname$ensembl_gene_id]
symbol_to_seurat_rowname = split(symbol_to_seurat_rowname$seurat_rowname, symbol_to_seurat_rowname$external_gene_name)

# Ensembl to entrez
ensembl_to_entrez = unique(annot_ensembl[, c("ensembl_gene_id", "entrezgene_accession")])
ensembl_to_entrez$entrezgene_accession = ifelse(nchar(ensembl_to_entrez$entrezgene_accession) == 0, NA, ensembl_to_entrez$entrezgene_accession)
ensembl_to_entrez = split(ensembl_to_entrez$entrezgene_accession, ensembl_to_entrez$ensembl_gene_id)

# Seurat-compatible unique rowname to entrez
seurat_rowname_to_ensembl_match = match(seurat_rowname_to_ensembl,names(ensembl_to_entrez))
names(seurat_rowname_to_ensembl_match) = names(seurat_rowname_to_ensembl)
seurat_rowname_to_entrez = purrr::map(seurat_rowname_to_ensembl_match, function(i) {unname(ensembl_to_entrez[[i]])})
```

```{r cc_genes_translate}
# Use biomart to translate human cell cycle genes to the species of interest
mart_human = biomaRt::useEnsembl("ensembl", dataset="hsapiens_gene_ensembl", mirror=mirror) 
mart_myspecies = biomaRt::useEnsembl("ensembl", dataset=param$mart_dataset, mirror=mirror) 

genes_s = biomaRt::getLDS(attributes=c("external_gene_name"), 
                          filters="external_gene_name", 
                          values=cc.genes.updated.2019$s.genes, 
                          mart=mart_human, 
                          attributesL=c("external_gene_name"), 
                          martL=mart_myspecies, 
                          uniqueRows=TRUE)
genes_g2m = biomaRt::getLDS(attributes=c("external_gene_name"), 
                            filters="external_gene_name", 
                            values=cc.genes.updated.2019$g2m.genes, 
                            mart=mart_human, 
                            attributesL=c("external_gene_name"), 
                            martL=mart_myspecies, 
                            uniqueRows=TRUE)
```

## Setup
We next read the scRNA-seq dataset(s) into Seurat. 
```{r read_datasets}
# List of Seurat objects
sc = list()

datasets = param$path_data
for (i in seq(nrow(datasets))) {
  name = datasets[i,"name"]
  type = datasets[i,"type"]
  path = datasets[i,"path"]
  
  # Read 10X or smartseq2
  if (type == "10x") {
    
    # Read 10X sparse matrix into a Seurat object
    sc[[name]] = ReadSparseMatrix(path, 
                                  project=name, 
                                  row_name_column=1, 
                                  convert_row_names=ensembl_to_seurat_rowname)
    
  } else if (type == "smartseq2") {
    
    # Read counts table into a Seurat object
    # Note: drop unneccessary columns, e.g. columns 2-6 for featureCounts results
    # Note: parse plate information (sample name, plate number, plate row and plate column) and return samples as datasets
    sc = c(sc,ReadCountsTable(path, project=name, row_name_column=1, convert_row_names=ensembl_to_seurat_rowname, parse_plate_information=TRUE, return_samples_as_datasets=TRUE))
  } 
}

# Check that sample names are unique between datasets: this can happen if multiple Smartseq2 datasets have a negative control (NC)
# In this case, just use the dataset name which is unique, e.g. set1.NC and set2.NC
sample_names = purrr::map(sc, function(s){ unique(as.character(s[[]][["orig.ident"]])) })
duplicate_sample_names = purrr::reduce(sample_names, intersect)
sc = purrr::map(list_names(sc), function(n) {
  if (any(sc[[n]][["orig.ident", drop=TRUE]] %in% duplicate_sample_names)) {
    sc[[n]][["orig.ident.old"]] = sc[[n]][["orig.ident"]]
    sc[[n]][["orig.ident"]] = n
    sc[[n]] = Seurat::SetIdent(sc[[n]], value="orig.ident")
  }
  return(sc[[n]])
})

# set up colors for samples
sample_names = purrr::flatten_chr(purrr::map(sc, function(s){ unique(as.character(s[[]][["orig.ident"]])) }))
param$col_samples = param$col_palette_samples()(length(sample_names))
names(param$col_samples) = sample_names
```


# Pre-processing
## Quality control 
We start the analysis by removing unwanted cells from the dataset(s). Three commonly used QC metrics include the number of unique genes detected in each cell ("nFeature_RNA"), the total number of molecules detected in each cell ("nCount_RNA"), and the percentage of counts that map to the mitochrondrial genome ("percent_mt"). If ERCC spike-in controls were used, the percentage of counts mapping to them is also shown ("percent_ercc").
```{r qc_criteria_tmp}
# needed for now: is there a better structure for cell filter criteria ?
param$cell_filter = purrr::map(list_names(sc), function(s) {
  if (s %in% names(param$cell_filter)) {
    return(param$cell_filter[[s]])
  } else {
    return(param$cell_filter)
  }
})

# same for feature filter criteria
param$features_filter = purrr::map(list_names(sc), function(s) {
  if (s %in% names(param$features_filter)) {
    return(param$features_filter[[s]])
  } else {
    return(param$features_filter)
  }
})
```

```{r qc_calculate_cell}
## CELLS ##

# Calculate percentage of counts in mitochondrial genes for each Seurat object
sc = purrr::map(sc, Seurat::PercentageFeatureSet, pattern=param$mt, col.name="percent_mt", assay="RNA")

# Calculate percentage of counts in ERCC for each Seurat object (if assay is available)
sc = purrr::map(sc, function(s) {
  if ("ERCC" %in% Seurat::Assays(s)) s$percent_ercc = s$nCount_ERCC/(s$nCount_ERCC + s$nCount_RNA)*100
  return(s)
  })

# Combine cell metadata of the Seurat objects into one big metadata
sc_cell_metadata = purrr::map_dfr(sc, function(s){ s[[]] }) %>% as.data.frame()

knitr::kable(head(sc_cell_metadata, 5), align="l", caption="Cell meta-data, top 5 rows") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%")

## FEATURES (only RNA assay at the moment) ##
sc = purrr::map(list_names(sc), function(n) {
  num_cells_expr = Matrix::rowSums(Seurat::GetAssayData(sc[[n]], slot="counts", assay="RNA") >= 1)
  num_cells_expr_threshold = Matrix::rowSums(Seurat::GetAssayData(sc[[n]], slot="counts", assay="RNA") >= param$features_filter[[n]][["min_counts"]])
  sc[[n]][["RNA"]] = Seurat::AddMetaData(sc[[n]][["RNA"]], data.frame(num_cells_expr,num_cells_expr_threshold))
  return(sc[[n]])
})

knitr::kable(head(sc[[1]][["RNA"]][[]], 5), align="l", caption="Feature meta-data for assay 'RNA', top 5 rows (only first dataset shown)") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%")

```


```{r qc_plot}
## CELLS ##

# Plot QC metrics for cells
cell_qc_features = c("nFeature_RNA", "nCount_RNA", "percent_mt")
if ("percent_ercc" %in% colnames(cell_qc_features)) cell_qc_features = c(cell_qc_features,"percent_ercc")
cell_qc_features = values_to_names(cell_qc_features)

p = list()
for (i in names(cell_qc_features)) {
  p[[i]]= ggplot(sc_cell_metadata,aes_string(x="orig.ident", y=i, fill="orig.ident")) +
    geom_violin(scale="width") +
    scale_fill_manual(values=param$col_samples) +
    theme_bw()
  p[[i]] = PlotMystyle(p[[i]], title=i, legend_position="none") + xlab("")
  
  
  cell_filter_for_plot = purrr::map_dfr(names(param$cell_filter), function(n) {
    if (i %in% names(param$cell_filter[[n]])){
      orig_ident_levels = unique(sc[[n]][["orig.ident", drop=TRUE]])
      purrr::map_dfr(orig_ident_levels, function(o) { data.frame(orig.ident=o, threshold=c("min","max"), value=param$cell_filter[[n]][[i]]) })
    } 
  })
  cell_filter_for_plot = cell_filter_for_plot %>% dplyr::filter(!is.na(value))
  if (nrow(cell_filter_for_plot)>0) {
    p[[i]] = p[[i]] + geom_segment(data=cell_filter_for_plot,aes(x=as.integer(as.factor(orig.ident))-0.5, xend=as.integer(as.factor(orig.ident))+0.5, y=value, yend=value),lty=2, col="orange")
  }
}
p = patchwork::wrap_plots(p, ncol = 3) + patchwork::plot_annotation("Distribution of feature values") 
p

# Correlate QC metrics for cells
p = list()
p[[1]] = ggplot(sc_cell_metadata,aes_string(x=cell_qc_features[2], y=cell_qc_features[1], colour="orig.ident")) +
  geom_point() +
  scale_colour_manual(values=param$col_samples) +
  theme_bw()
p[[2]] = ggplot(sc_cell_metadata,aes_string(x=cell_qc_features[2], y=cell_qc_features[3], colour="orig.ident")) +
  geom_point() +
  scale_colour_manual(values=param$col_samples) +
  theme_bw()
for (i in 1:length(p)) p[[i]] = PlotMystyle(p[[i]], legend_position="none")
p = patchwork::wrap_plots(p, ncol = 2) + patchwork::plot_annotation("Features plotted against each other") 
p

## FEATURES (only RNA assay at the moment) ##

# Plot QC metrics for genes ?
# sss
```

```{r filtering}
## CELLS ##

# Iterate over datasets and then over filters
# Record a cell if it does not pass the filter; also record cell if it belongs to a sample that should be dropped anyway
sc_filtered_cells = purrr::map(list_names(sc), function(n) {
  # Filters
  filter_result = purrr::map(list_names(param$cell_filter[[n]]), function(f) {
    filter = param$cell_filter[[n]][[f]]
    if (is.numeric(filter)){
      if (is.na(filter[1])) filter[1] = -Inf
      if (is.na(filter[2])) filter[2] = Inf
      return(names(which(sc[[n]][[f, drop=TRUE]] < filter[1] | sc[[n]][[f, drop=TRUE]] > filter[2])))
    } else if (is.character(filter)) {
      return(names(which(sc[[n]][[f, drop=TRUE]] %in% filter)))
    }
  })

  # Samples to drop
  cell_identities = sc[[n]][["orig.ident", drop=TRUE]]
  filter_result[["sample_to_drop"]] = names(cell_identities[cell_identities %in% param$samples_to_drop])
  return(filter_result)
})

# Summarise
sc_filtered_cells_summary = purrr::map_dfr(sc_filtered_cells,function (s) {
  return(as.data.frame(purrr::map(s,length))) 
  })
rownames(sc_filtered_cells_summary) = names(sc_filtered_cells)
knitr::kable(sc_filtered_cells_summary, align="l", caption="Cell filtering summary") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%")

# Now filter, drop the respective colours and adjust integration method
sc = purrr::map(list_names(sc), function(n) {
  cells_to_keep = Cells(sc[[n]])
  cells_to_keep = cells_to_keep[!cells_to_keep %in% purrr::flatten_chr(sc_filtered_cells[[n]])]
  return(subset(sc[[n]], cells=cells_to_keep))
})
if(length(sc)==1) param$integrate_samples[["method"]] = "single"

sample_names = purrr::flatten_chr(purrr::map(sc, function(s){ unique(as.character(s[[]][["orig.ident"]])) }))
param$col_samples = param$col_samples[names(param$col_samples) %in% sample_names]

## FEATURES (only RNA assay at the moment) ##

# Iterate over datasets and record a feature if it does not pass the filter
sc_filtered_features  = purrr::map(list_names(sc), function(n) {
  names(which(sc[[n]][["RNA"]][["num_cells_expr_threshold", drop=TRUE]] < param$features_filter[[n]][["min_cells"]]))
})

# Summarise
sc_filtered_features_summary = as.data.frame(purrr::map(sc_filtered_features, length))
rownames(sc_filtered_features_summary) = c("Genes")
knitr::kable(sc_filtered_features_summary, align="l", caption="Gene filtering summary") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%")

# Now filter
sc = purrr::map(list_names(sc), function(n) {
  features_to_keep = purrr::flatten_chr(purrr::map(Assays(sc[[n]]), function(a){rownames(sc[[n]][[a]])}))
  features_to_keep = features_to_keep[!features_to_keep %in% sc_filtered_features[[n]]]
  return(subset(sc[[n]], features=features_to_keep))
})
```

## Normalisation, cell cycle scoring, scaling and variable features
In this section, we subsequently run a series of Seurat functions:  
1. We start by running a __standard log normalisation__, where counts for each cell are divided by the total counts for that cell and multiplied by 10,000. This is then natural-log transformed.   
2. To be able to compare normalised gene counts between genes, gene counts are further __scaled__ to have zero mean and unit variance (z-score). This way, genes are equally weighted for downstream analysis.  
3. __Variable features__ are selected. For downstream analysis it is beneficial to focus on genes that exhibit high cell-to-cell variation, that is they are highly expressed in some cells and lowly expressed in others. 

In addition, we run:  
4. __SCTransform__, a new and more sophisticated normalisation method that replaces the previous functions (__normalisation, scaling and variable features__). Note that although results are kept for steps 1-3 ("RNA" assay), downstream analyses will default to resulting data of step 4 ("SCT" assay). 

If specified in the above parameter section, __cell cycle scores__ are assigned to each cell based on its normalised expression of G2/M and S phase markers, after basic normalisation (step 1). Cell cycle effects are then removed during scaling (step 4). Done for this report: `r param$cc_remove`. 

```{r norm_scale_variableFeatures, results="hide"}
# This function often crashes with multicore support, so stop for a moment
future::plan("sequential")

# Normalise data the original way
sc = purrr::map(sc, Seurat::NormalizeData, normalization.method = "LogNormalize", scale.factor=10000, verbose=FALSE)

# Back to multicore support
future::plan("multicore")

# Probably obsolete, not needed anywhere in this report
# Select features from normalised data (unaffected by scaling)
sc = purrr::map(sc, Seurat::FindVariableFeatures, selection.method = "vst", nfeatures = 3000, verbose=FALSE)

# Scaling "RNA" normalised counts is required to run PCA, which again is required for the JackStraw plot
# Note that we do NOT remove cell cycle effects in "RNA" scaled data, since this is very slow and 
#   only used for the JackStraw plot
sc = purrr::map(sc, function(s) { Seurat::ScaleData(s, features=VariableFeatures(s), verbose=FALSE, vars.to.regress=param$vars_to_regress) })
```

```{r cc_scores, eval=param$cc_remove}
# If cell cycle effects should be removed, we first score cells 
# The effect is then removed in the following chunk 
if(param$cc_remove) {
  # Determine cell cycle effect
  sc = purrr::map(sc, Seurat::CellCycleScoring, s.features=genes_s[,2], g2m.features=genes_g2m[,2], set.ident=FALSE)
  # Determine difference between G2M and S phase scores
  sc = purrr::map(sc, function(s) {
    s$CC.Difference = s$S.Score - s$G2M.Score
    return(s)
  })
  # Add to vars that need to regressed out during normalisation
  if (param$cc_remove_all) {
    # Regress out cell cycle effect
    param$vars_to_regress = unique(c(param$vars_to_regress,"S.Score", "G2M.Score"))
    param$latent_vars = unique(c(param$latent_vars,"S.Score", "G2M.Score"))
  } else {
    # Remove all signal associated to cell cycle
    param$vars_to_regress = unique(c(param$vars_to_regress,"CC.Difference"))
    param$latent_vars = unique(c(param$latent_vars,"CC.Difference"))
  }
}
```

```{r regress_and_sctransform, results="hide"}
# Scale RNA assay
sc = purrr::map(sc, function(s) { Seurat::ScaleData(s, features=VariableFeatures(s), vars.to.regress=param$vars_to_regress,  verbose=FALSE) })

# Run SCTransform
#
# This is a new normalisation method that replaces previous Seurat functions 'NormalizeData', 'FindVariableFeatures', and 'ScaleData'. 
# vignette: https://satijalab.org/seurat/v3.0/sctransform_vignette.html
# paper: https://www.biorxiv.org/content/10.1101/576827v2
# Normalised data end up here: sc@assays$SCT@data
sc = purrr::map(list_names(sc), function(n) { SCTransform(sc[[n]], vars.to.regress=param$vars_to_regress, min_cells=param$features_filter[[n]][["min_cells"]], verbose=FALSE) })

# Note: If I write Seurat::SCTransform, I get the following error message in the next chunk for
#   Seurat::VariableFeaturePlot(sc, cols=c("grey", param$col)) 
#   'vst' is Unable to find highly variable feature information for method 'vst'
#
#   Same is true for: purrr::map(sc, SCTransform vars.to.regress=param$vars_to_regress)
#
#   Maybe solved: check meta information for features, e.g. sc[["RNA"]][[]] for sct or vst columns; usually RNA - vst and SCT - sct
```

### Variable features  {.tabset}

Variable features are .... .

#### Standard normalisation (RNA)

```{r plot_variable_features_rna}
# Show variable genes
plist = purrr::map(list_names(sc), function(n) {
  top10 = head(Seurat::VariableFeatures(sc[[n]]), 10)
  p = Seurat::VariableFeaturePlot(sc[[n]], cols=c("grey", param$col), assay="RNA", selection.method="vst") + ggtitle(n)
  p = PlotMystyle(p)
  p = LabelPoints(plot=p, points=top10, repel=TRUE)
  p = p + theme(legend.position=c(0.2, 0.8),legend.background=element_rect(fill=alpha("white", 0.0)))
  return(p)
})

patchwork::wrap_plots(plist) + patchwork::plot_annotation("Variable genes")
```

#### Advanced normalisation (SCT)

```{r plot_variable_features_sct}
# Show variable genes
plist = purrr::map(list_names(sc), function(n) {
  top10 = head(Seurat::VariableFeatures(sc[[n]], assay="SCT"), 10)
  p = Seurat::VariableFeaturePlot(sc[[n]], cols=c("grey", param$col), assay="SCT", selection.method="sct") + ggtitle(n)
  p = PlotMystyle(p)
  p = LabelPoints(plot=p, points=top10, repel=TRUE)
  p = p + theme(legend.position=c(0.2, 0.8),legend.background=element_rect(fill=alpha("white", 0.0)))
  return(p)
})

patchwork::wrap_plots(plist) + patchwork::plot_annotation("Variable genes")
```

</div>

### Relative log expression {.tabset}

```{r plot_norm_prep}
n_cells_rle_plot = 100
# Sample at most 100 cells per dataset and save their identity; also get list of features shared among datasets
cell_subset_ids = purrr::map(sc, function(s) {
  cells = Seurat::Cells(s)
  cell_subset = sample(cells, min(n_cells_rle_plot, length(cells)))
  cell_subset = sort(setNames(as.character(s[[]][cell_subset, "orig.ident", drop=TRUE]),cell_subset))
  return(cell_subset)
})
cell_identities = purrr::flatten_chr(cell_subset_ids)
cell_subset_ids = purrr::map(cell_subset_ids, names)
shared_rna_features = purrr::reduce(purrr::map(sc, function(s) { rownames(s[["RNA"]]) }), intersect)
shared_sct_features = purrr::reduce(purrr::map(sc, function(s) { rownames(s[["SCT"]]) }), intersect)
```

To better understand the efficiency of the applied normalisation procedures, we plot the relative log expression of genes in `r n_cells_rle_plot` randomly selected cells per sample before and after normalisation. This type of plot reveals unwanted variation in your data. The concept is taken from `r knitcitations::citet("10.1371/journal.pone.0191629")`. In brief, we remove variation between genes, leaving only variation between samples. If expression levels of most genes are similar in all cell types, sample heterogeneity is a sign of unwanted variation. 

For each gene, we calculate its median expression across all cells, and then calculate the deviation from this median for each cell. For each cell, we plot the median expression (black), the interquartile range (lightgrey), whiskers defined as 1.5 times the interquartile range (darkgrey), and outliers (`r param$col`). 

#### Raw counts
```{r plot_norm_raw}
# Get counts from assay RNA
cell_subset_raw = purrr::map(seq(length(sc)), function(i) {
  d = GetAssayData(subset(sc[[i]], cells=cell_subset_ids[[i]], features=shared_rna_features), assay="RNA", slot="counts")
  colnames(d) = paste(colnames(d), i, sep=".")
  return(d)
})
cell_subset_raw = purrr::reduce(cell_subset_raw, cbind)

# Plot
p = PlotRLE(as.matrix(log2(cell_subset_raw + 1)), id=cell_identities, col=param$col_samples) + labs(title="log2(raw counts + 1)")
p
```

#### Standard normalisation (RNA)
```{r plot_norm_norm}
# Get normalised data from assay RNA
cell_subset_norm1 = purrr::map(seq(length(sc)), function(i) {
  d = GetAssayData(subset(sc[[i]], cells=cell_subset_ids[[i]], features=shared_rna_features), assay="RNA", slot="data")
  colnames(d) = paste(colnames(d), i, sep=".")
  return(d)
})
cell_subset_norm1 = purrr::reduce(cell_subset_norm1, cbind)

# Plot
p = PlotRLE(as.matrix(cell_subset_norm1), id=cell_identities, col=param$col_samples) + labs(title="Normalised data")
p 
```

#### Advanced normalisation (SCT)
```{r plot_norm_sct}
# Get normalised data from assay SCT
cell_subset_norm2 = purrr::map(seq(length(sc)), function(i) {
  d = GetAssayData(subset(sc[[i]], cells=cell_subset_ids[[i]], features=shared_sct_features), assay="SCT", slot="data")
  colnames(d) = paste(colnames(d), i, sep=".")
  return(d)
})
cell_subset_norm2 = purrr::reduce(cell_subset_norm2, cbind)

# Plot
p = PlotRLE(as.matrix(cell_subset_norm2), id=cell_identities, col=param$col_samples) + labs(title="SCTransform'ed data")
p 
```

<!-- https://stackoverflow.com/questions/38062706/rmarkdown-how-to-end-tabbed-content -->
</div>

```{r multi_dataset_integration_single, eval=(param$integrate_samples[["method"]]=="single"), include=(param$integrate_samples[["method"]]=="single")}
# Called when there there are multiple datasets but no integration is needed (e.g. samples were multiplexed on the same chip)
if (param$integrate_samples[["method"]]=="single") {
  sc = sc[[1]]
}
```

```{r multi_dataset_integration_preparation, eval=(param$integrate_samples[["method"]]!="single"), include=(param$integrate_samples[["method"]]!="single"), results="asis"}
if (param$integrate_samples[["method"]]!="single") {
  
  # Markdown text for this section (do not change intendation)
cat("## Integration of multiple datasets\n\n")
  

  # Feature metadata is removed by Seurat merge entirely; save separately for each assay and add again afterwards
  assay_names = unique(purrr::flatten_chr(purrr::map(list_names(sc), function(n) { Assays(sc[[n]]) } )))
  feature_data_for_assay = purrr::map(values_to_names(assay_names), function(a) {
    # For feature_id, feature_name and feature_type, we keep only one set of columns
    # Note: some assays do not have these columns, so skip
    contains_neccessary_columns = purrr::map_lgl(list_names(sc), function(n) { all(c("feature_id","feature_name","feature_type") %in% colnames(sc[[n]][[a]][[]])) })
    
    if (all(contains_neccessary_columns)) {
      feature_id_name_type = purrr::reduce(list_names(sc), function(x, y) {
        df_x = sc[[x]][[a]][[c("feature_id", "feature_name", "feature_type")]]
        df_y = sc[[y]][[a]][[c("feature_id", "feature_name", "feature_type")]]
        new_rows = which(!rownames(df_y) %in% rownames(df_x))
        rbind(df_x, df_y[new_rows,])
      })
      feature_id_name_type$Rownames = rownames(feature_id_name_type)
    } else {
      feature_id_name_type = NULL
    }
    
    # For all other metadata, we prefix column names with the dataset
    other_feature_data = purrr::map(list_names(sc), function(n) {
      df = sc[[n]][[a]][[]] %>% dplyr::select(-one_of("feature_id","feature_name","feature_type"))
      colnames(df) = paste(n, colnames(df), sep=".")
      df$Rownames = rownames(df)
      return(df)
    })
    
    # Now join everything by Rownames and full outer join
    if(!is.null(feature_id_name_type)) {
      feature_data = purrr::reduce(c(list(feature_id_name_type=feature_id_name_type),other_feature_data), dplyr::full_join, by="Rownames")
    } else {
      feature_data = purrr::reduce(other_feature_data, dplyr::full_join, by="Rownames")
    }
    rownames(feature_data) = feature_data$Rownames
    feature_data$Rownames = NULL
    
    return(feature_data)
  })
}
```

```{r multi_dataset_integration_merge, eval=(param$integrate_samples[["method"]]=="merge"), include=(param$integrate_samples[["method"]]=="merge")}
# Called when there is only one dataset and no integration needed
if (param$integrate_samples[["method"]]=="merge") {
   sc = merge(x=sc[[1]], y=sc[2:length(sc)], project=param$project)
}
```

```{r multi_dataset_integration_standard, eval=(param$integrate_samples[["method"]]=="standard"), include=(param$integrate_samples[["method"]]=="standard")}
# Standard method for integrating multiple samples. Best performance but computationally intensive.
if (param$integrate_samples[["method"]]=="standard") {
  # Note "Assay names should only have numbers and letters: Warnung: Keys should be one or more alphanumeric characters followed by an underscore, setting key from rna_integrated_ to rnaintegrated_"
  
  # The integration step will temporarily occupy lots of memory. However, R has problems with freeing unused memory.
  # By wrapping the steps into a function, hopefully this works a bit better.
  run_standard_integration = function(sc_objs, ndims=30, vars_to_regress=c()) {
    # Find integration anchors for assay RNA
    integrate_RNA_features = Seurat::SelectIntegrationFeatures(object.list=sc_objs, nfeatures=3000, assay=rep("SCT", length(sc)), verbose=FALSE)
    integrate_RNA_anchors = Seurat::FindIntegrationAnchors(object.list=sc_objs, normalization.method="LogNormalize", anchor.features=integrate_RNA_features, dims=1:ndims, assay=rep("RNA", length(sc_objs)), verbose=FALSE)
    tmp_sc_objs = Seurat::IntegrateData(integrate_RNA_anchors, new.assay.name="RNAintegrated", normalization.method="LogNormalize", dims=1:ndims, verbose=FALSE)
    
    sc_obj_RNAintegrated_assay = Seurat::GetAssay(tmp_sc_objs, assay="RNAintegrated")
    rm(tmp_sc_objs, integrate_RNA_anchors, integrate_RNA_features)
    
    # Find integration anchors for assay SCT
    integrate_SCT_features = SelectIntegrationFeatures(object.list=sc_objs, nfeatures=3000, assay=rep("SCT", length(sc)), verbose=FALSE)
    sc_objs = PrepSCTIntegration(object.list=sc_objs, anchor.features=integrate_SCT_features, verbose=TRUE)
    integrate_SCT_anchors = FindIntegrationAnchors(object.list=sc_objs, normalization.method="SCT", anchor.features=integrate_SCT_features, assay=rep("SCT", length(sc_objs)), verbose=FALSE)
    sc_objs = Seurat::IntegrateData(integrate_SCT_anchors, new.assay.name="SCTintegrated", normalization.method="SCT", dims=1:ndims, verbose=FALSE)
    sc_objs[["RNAintegrated"]] = sc_obj_RNAintegrated_assay
    rm(integrate_SCT_anchors, integrate_SCT_features, sc_obj_RNAintegrated_assay)
    
    # scale data: according to seurat, this is needed only for the integrated RNA assay
    sc_objs = Seurat::ScaleData(sc_objs, features=rownames(sc_objs[["RNAintegrated"]]), verbose=FALSE, vars.to.regress=vars_to_regress, assay="RNAintegrated")
    
    # Call garbage collector to free memory (hope it helps)
    gc()
    return(sc_objs)
  }
  
  # call function
  sc = run_standard_integration(sc, ndims=param$integrate_samples[["dimensions"]], vars_to_regress=param$vars_to_regress)
}
```

```{r multi_dataset_integration_reference, eval=(param$integrate_samples[["method"]]=="reference"), include=(param$integrate_samples[["method"]]=="reference")}
# Method uses one dataset as reference and all other datasets are integrated into this dataset. Faster but lower performance.
if (param$integrate_samples[["method"]]=="reference") {
   stop("Not yet implemented")
}
```

```{r multi_dataset_integration_reciprocal, eval=(param$integrate_samples[["method"]]=="reciprocal"), include=(param$integrate_samples[["method"]]=="reciprocal")}
# Method computes anchors in PCA space instead of the data. Even less accurate but for very big datasets.
if (param$integrate_samples[["method"]]=="reciprocal") {
   stop("Not yet implemented")
}
```


```{r plot_norm_norm_integrated, eval=(param$integrate_samples[["method"]]!="single"), include=(param$integrate_samples[["method"]]!="single"), results="asis"}
if (param$integrate_samples[["method"]]!="single") {
  # Markdown text for this section (do not change intendation)
cat("\n\n### Relative log expression after integration {.tabset}\n\n")
cat("#### Standard normalisation (RNA)\n\n")
  
  # Get normalised data from assay RNAintegrated and plot RLE
  cell_subset_norm1 = GetAssayData(subset(sc, cells=purrr::flatten_chr(cell_subset_ids), features=shared_rna_features), assay="RNAintegrated", slot="data")
  PlotRLE(as.matrix(cell_subset_norm1), id=cell_identities, col=param$col_samples) + labs(title="Normalised integrated data")
}
```
  
```{r plot_norm_sct_integrated, eval=(param$integrate_samples[["method"]]!="single"), include=(param$integrate_samples[["method"]]!="single"), results="asis"}
if (param$integrate_samples[["method"]]!="single") {
# Markdown text for this section (do not change intendation)
cat("\n\n#### Advanced normalisation (SCT)\n\n")
  
  # Get normalised data from assay SCTintegrated and plot RLE
  cell_subset_norm2 = GetAssayData(subset(sc, cells=purrr::flatten_chr(cell_subset_ids), features=shared_rna_features), assay="SCTintegrated", slot="data")
  PlotRLE(as.matrix(cell_subset_norm2), id=cell_identities, col=param$col_samples) + labs(title="SCTransform'ed integrated data")
}
  
```

```{r plot_norm_sct_integrated_done, eval=(param$integrate_samples[["method"]]!="single"), include=(param$integrate_samples[["method"]]!="single"), results="asis"}
# this is neccessary for closing the tabset
if (param$integrate_samples[["method"]]!="single") {
  cat("\n\n</div>\n\n")
}
```

## Dimensionality reduction
A single-cell dataset of 20,000 genes and 5,000 cells has 20,000 dimensions. The biological manifold however can be described by far fewer dimensions than the number of genes. Dimension reduction methods aim to find these dimensions. There are two general purposes for dimension reduction methods: to summarise a dataset, and to visualise a dataset. 

We use Principal Component Analysis (PCA) to summarise a dataset, overcoming noise and reducing the data to its essential components. Each principal component (PC) represents a "metafeature" that combines information across a correlated gene set. Later, we use Uniform Manifold Approximation and Projection (UMAP) to visualise the dataset, placing similar cells together in 2D space, see below. 

To decide how many PCs to include in downstream analyses, we visualize cells and genes that define the PCA. 
```{r pca}
DefaultAssay(sc) = "RNAintegrated"

# Run PCA for "RNA" assay; this is required for the JackStraw plot
sc = Seurat::RunPCA(sc, features=Seurat::VariableFeatures(object=sc))

# Run PCA for the default "SCT" assay
#sc = Seurat::RunPCA(sc, features=Seurat::VariableFeatures(object=sc))

p = Seurat::VizDimLoadings(sc, dims=1:2, reduction="pca", col=param$col, combine=FALSE)
for (i in 1:length(p)) p[[i]] = PlotMystyle(p[[i]])
p =  patchwork::wrap_plots(p, ncol = 2) + patchwork::plot_annotation("Top gene loadings of the first two PCs") 
p

p = Seurat::DimPlot(sc, reduction="pca", cols=param$col_samples)
p = PlotMystyle(p, title="Cells arranged by the first two PCs", legend_position="bottom")
p

Seurat::DimHeatmap(sc, dims=1, cells=500, balanced=TRUE)
```

```{r pca_heatmaps, fig.height=20}
Seurat::DimHeatmap(sc, dims=1:20, cells=500, balanced=TRUE)
```

## Dimensionality of the dataset
We next need to decide how many PCs we want to use for downstream analyses. The following two plots are designed to help us make an informed decision. 

The first plot is based on the "JackStraw" procedure: parts of the data is repeatedly randomly permuted and PCA is rerun, generating a "null distribution" of feature scores. Significant PCs are those with a strong enrichment of low p-value features. 

The second plot is an "Elbow plot": PCs are ranked based on the percentage of variance they explain. 

For your dataset, we decided to go for `r param$pc_n` PCs. 
```{r dimensionality, results="hide"}
# NOTE: This process can take a long time for big datasets, comment out for expediency. More
# approximate techniques such as those implemented in ElbowPlot() can be used to reduce
# computation time
sc = Seurat::JackStraw(sc, num.replicate=100, dims=20)
sc = Seurat::ScoreJackStraw(sc, dims=1:20)
p = Seurat::JackStrawPlot(sc, dims=1:20)
p = PlotMystyle(p, title="Jack Straw plot", legend_position="bottom")
#p

p = Seurat::ElbowPlot(sc, ndims=20)
p = PlotMystyle(p, title="Elbow plot")
p
```

# Downstream analysis
## Clustering
Seurat's clustering method first constructs a graph structure, where nodes are cells and edges are drawn between cells with similar gene expression patterns. Technically speaking, Seurat first constructs a K-nearest neighbor (KNN) graph based on Euclidean distance in PCA space, and refines edge weights between cells based on the shared overlap in their local neighborhoods (Jaccard similarity). To partition the graph into highly interconnected parts, cells are iteratively grouped together using the Leiden algorithm. 
```{r clustering}
# Note: I changed the seed in ./lib/python3.6/site-packages/leidenalg/functions.py to 11 for reproducibility
# The number of clusters can be optimized by tuning 'resolution' -> based on feedback from the client whether or not clusters make sense

# Choose the number of PCs to use for clustering
sc = Seurat::FindNeighbors(sc, dims=1:param$pc_n)

# Cluster using the Leiden algorithm
# Paper to Leiden algorithm: https://www.nature.com/articles/s41598-019-41695-z
# Seurat vignette suggests resolution parameter between 0.4-1.2 for datasets of about 3k cells
sc = Seurat::FindClusters(sc, resolution=param$cluster_resolution, algorithm=4)
```

## Visualisation with UMAP
We use a UMAP to visualise and explore a dataset. The goal is to place similar cells together in 2D space, and learn about the biology underlying the data. Cells are color-coded according to the graph-based clustering, and clusters typcially co-localise on the UMAP. 

Take care not to mis-read a UMAP:  

* Parameters influence the plot (we use defaults here)  
* Cluster sizes relative to each other mean nothing, since the method has a local notion of distance  
* Distances between clusters might not mean anything  
* You may need more than one plot  
  
For a nice read to intuitively understand UMAP, see `r knitcitations::citep("https://pair-code.github.io/understanding-umap/")`. 
```{r umap, message=FALSE, results="hide"}
sc = Seurat::RunUMAP(sc, dims=1:param$pc_n)

# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
cluster_cells = table(sc@active.ident)
cluster_labels = paste0(levels(sc@active.ident)," (", cluster_cells[levels(sc@active.ident)],")")
p = Seurat::DimPlot(sc, reduction="umap", label=TRUE) + scale_colour_discrete("Cluster", labels=cluster_labels)
p = PlotMystyle(p, "UMAP, cells coloured by cluster identity", legend_position="bottom")
p
```

## Cell Cycle Effect
How much do gene expression profiles in your dataset reflect the cell cycle phases the single cells were in? We determine the effects of cell cycle heterogeneity by calculating a score for each cell based on its expression of G2M and S phase markers. Scoring is based on the strategy described in `r knitcitations::citet("10.1126/science.aad0501")`, and human gene names are translated using biomaRt. 
```{r cellCycleEffect}
# Determine cell cycle effect, this time based on default assay "SCT"
sc = Seurat::CellCycleScoring(object=sc, s.features=genes_s[,2], g2m.features=genes_g2m[,2], set.ident=FALSE)

# Get a feeling for how many cells are affected
p1 = ggplot(sc@meta.data, aes(x=S.Score, y=G2M.Score, colour=Phase)) + 
  geom_point() + 
  scale_x_continuous("G1/S score") + 
  scale_y_continuous("G2/M score")
p1 = PlotMystyle(p1)
p2 = ggplot(sc@meta.data %>% 
              dplyr::group_by(seurat_clusters,Phase) %>% 
              dplyr::summarise(num_reads=length(Phase)), 
            aes(x=seurat_clusters, y=num_reads, fill=Phase)) + 
  geom_bar(stat="identity", position="fill") + 
  scale_x_discrete("Seurat clusters") + 
  scale_y_continuous("Fraction of cells")
p2 = PlotMystyle(p2)
p = p1 + p2 & theme(legend.position="bottom")
p = p + patchwork::plot_annotation(title="Cell cycle phases")
p

# UMAP with phases superimposed
p = Seurat::DimPlot(sc, group.by="Phase", pt.size=1)
PlotMystyle(p, title="UMAP, cells coloured by cell cycle phases", legend_title="Phase")

```

```{r cellCycleEffect_featurePlot, fig.height=10}
p1 = Seurat::FeaturePlot(sc, features="S.Score", pt.size=1, min.cutoff="q1", max.cutoff="q99", cols=c("lightgrey", param$col))
p1 = PlotMystyle(p1, title="UMAP, cells coloured by S phase")
p2 = Seurat::FeaturePlot(sc, features="G2M.Score", pt.size=1, min.cutoff="q1", max.cutoff="q99", cols=c("lightgrey", param$col))
p2 = PlotMystyle(p2, title="UMAP, cells coloured by G2M phase")
p = p1 + p2
p 
```

## Feature plots QC
Do cells in individual clusters have particularly high counts, detected genes or mitochondrial content?
```{r featurePlot_QC, fig.height=10}
p = Seurat::FeaturePlot(sc, features=cell_qc_features, cols=c("lightgrey", param$col), combine=FALSE)
names(p) = cell_qc_features
for (i in cell_qc_features) p[[i]] = PlotMystyle(p[[i]], title=i)
patchwork::wrap_plots(p, ncol=2)
```

## Feature plots for known marker genes
Do cells in individual clusters express provided known marker genes?
```{r featurePlot_markerGenes, eval=TRUE}
g = unique(unlist(param$known_markers))
g = g[length(g):1]
p = Seurat::DotPlot(sc, features=g, cols=c("lightgrey", param$col)) + 
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5))
p = PlotMystyle(p, title="Dot plot of known marker genes")
p

# Todo: add feature plots!
```

## Differentially expressed genes
We next identify genes that are differentially expressed in one cluster compared to all other clusters. Additional gene annotation is added, and the resulting tables are written to file. 
```{r DEG}
# We load and unload the MAST R package in this chunk, as it overwrites Seurat functions
library(MAST)

# Find markers for every cluster compared to all remaining cells, report positive and negative ones
# min.pct = requires feature to be detected at this minimum percentage in either of the two groups of cells 
# logfc.threshold = requires a feature to be differentially expressed on average by some amount between the two groups
# only.pos = find only positive markers 

# Should cell cycle effects be ignored?
latent_vars=NULL
if(param$cc_remove) {
  if(param$cc_remove_all) {
    latent_vars = c("S.Score", "G2M.Score")
  } else {
    latent_vars = "CC.Difference"
  }
} 

# Review recommends using "MAST"; Mathias uses "LR"
# ALWAYS USE: assay="RNA" or assay="SCT"
# DONT USE: assay=integrated datasets; this data is normalised and contains only 2k genes
sc_markers = Seurat::FindAllMarkers(sc, assay="RNA", test.use="MAST",
                                    only.pos=FALSE, min.pct=0.25, logfc.threshold=0.25,
                                    latent.vars=param$latent_vars)

sc_markers_top2 = sc_markers %>% 
  dplyr::group_by(cluster) %>% 
  dplyr::top_n(n=2, wt=avg_logFC) %>% 
  as.data.frame()

# Show top 2 merkers per cluster
knitr::kable(sc_markers_top2, align="l", caption="Top 2 DEGs per cell cluster") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))

# Add Ensembl annotation
sc_markers_ensembl = seurat_rowname_to_ensembl[sc_markers[,"gene"]]
sc_markers_annot = cbind(sc_markers, annot_ensembl[sc_markers_ensembl,])

# Output in Excel sheet
sc_markers_lst = lapply(levels(sc_markers_annot$cluster), function(x) {sc_markers_annot %>% dplyr::filter(cluster==x)})
names(sc_markers_lst) = paste0("cluster", levels(sc_markers$cluster))
openxlsx::write.xlsx(sc_markers_lst, file=paste0(param$path_out, "/markers.xlsx"))

# Filter markers based on p-value and fold-change 
sc_markers_filt = sc_markers %>% 
  dplyr::filter(p_val_adj <= param$padj) %>% 
  dplyr::filter((avg_logFC <= -param$log2fc) | (avg_logFC >= param$log2fc)) %>% 
  as.data.frame()
sc_markers_filt_down = sc_markers_filt %>% 
  dplyr::filter(avg_logFC <= -param$log2fc) %>% 
  as.data.frame()
sc_markers_filt_up = sc_markers_filt %>% 
  dplyr::filter(avg_logFC >= param$log2fc) %>% 
  as.data.frame()

# Number of DEGs per cluster
cluster_all = sort(unique(sc_markers[,"cluster"]))
sc_markers_filt_n = cbind(Cluster=cluster_all, 
                          Down=sapply(cluster_all, function(x) sum(sc_markers_filt_down$cluster == x)), 
                          Up=sapply(cluster_all, function(x) sum(sc_markers_filt_up$cluster == x))) %>% 
  as.data.frame() %>% 
  tidyr::pivot_longer(cols=c("Down", "Up"), 
                      names_to="Direction", 
                      values_to="n")
sc_markers_filt_n$Cluster = as.factor(sc_markers_filt_n$Cluster)

p = ggplot(sc_markers_filt_n, aes(x=Cluster, y=n, fill=Direction)) + geom_bar(stat="identity") 
p = PlotMystyle(p, 
                title=paste0("Number of DEGs per cell cluster\n(FC=", 2^param$log2fc, ", adj. p-value=", param$padj, ")"), 
                col=c("steelblue", "darkgoldenrod1"))
p

# Unload the MAST R package
detach("package:MAST", unload=TRUE)
```

## Visualisation of differentially expressed genes
The following plots are exemplary to how we can visualize differentially expressed genes using the "Seurat" R-package. The selected genes are the top differentially expressed genes for all clusters, respectively. 
```{r DEG_plot_umap, fig.height=10}
# Get top gene per cluster and plot
genes_example = sc_markers %>% 
  dplyr::group_by(cluster) %>% 
  dplyr::top_n(n=1, wt=avg_logFC) %>% 
  dplyr::pull(gene) %>% 
  unique()

# Shows gene expression on the UMAP
p = Seurat::FeaturePlot(sc, features=genes_example, cols=c("lightgrey", param$col), combine=FALSE)
names(p) = genes_example
for (i in names(p)) p[[i]] = PlotMystyle(p[[i]], title=i)
p = patchwork::wrap_plots(p, ncol=2) + 
  patchwork::plot_annotation(title="UMAP, cells coloured by normalised gene expression data")
p
```

```{r DEG_plot_ridge, fig.height=10}
# Ridge plot of raw gene expression counts
p = Seurat::RidgePlot(sc, features=genes_example, slot="counts", combine=FALSE, assay="RNA")
names(p) = genes_example
for (i in names(p)) p[[i]] = PlotMystyle(p[[i]], title=i, legend_title="Cell identity")
p = patchwork::wrap_plots(p, ncol=2) + 
  patchwork::plot_annotation(title="Ridge plot of raw gene expression counts") + 
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position="bottom")
p

# Ridge plot of normalised gene expression data
p = Seurat::RidgePlot(sc, features=genes_example, combine=FALSE, assay="RNA")
names(p) = genes_example
for (i in names(p)) p[[i]] = PlotMystyle(p[[i]], title=i, legend_title="Cell identity")
p = patchwork::wrap_plots(p, ncol=2) + 
  patchwork::plot_annotation(title="Ridge plot of normalised gene expression data") + 
  patchwork::plot_layout(guides = "collect") &
  theme(legend.position="bottom")
p
```

```{r DEG_plot_dot}
# Visualises how feature expression changes across different clusters
p = Seurat::DotPlot(sc, features=genes_example[length(genes_example):1], cols=c("lightgrey", param$col), assay="RNA")
p = PlotMystyle(p, title="Dot plot of normalised gene expression data")
p
```

```{r DEG_heatmap, fig.height=20}
# Heatmap of top differentially expressed genes
top = sc_markers %>% 
  dplyr::group_by(cluster) %>% 
  dplyr::top_n(n=10, wt=avg_logFC)
p = Seurat::DoHeatmap(sc, features=top$gene) + NoLegend()
p
```

## Functional enrichment analysis
To gain first insights into potential functions of cells in a cluster, we test for over-representation of functional terms amongst up- and down-regulated genes of each cluster. Over-represented terms are written to file.  

We first translate gene symbols of up- and down-regulated genes per cluster into Entrez gene symbols, and then use the "enrichR" R-package to access the "Enrichr" website `r knitcitations::citep("https://amp.pharm.mssm.edu/Enrichr/")`. You can choose to test functional enrichment from a wide range of databases:
```{r enrichr_databases}
dbs_all = enrichR::listEnrichrDbs()
knitr::kable(dbs_all, align="l", caption="Enrichr databases") %>% 
  kableExtra::kable_styling(bootstrap_options=c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%", height="300px")
```

```{r functional_enrichment, results="hide"}
# DEGs up and down per cluster
cluster_all = sort(unique(sc_markers[,"cluster"]))
genesets_up = lapply(cluster_all, function(x) {
  tmp = sc_markers_filt_up %>% 
    dplyr::filter(cluster==x) %>% 
    dplyr::pull(gene)
  # Pick the first matching Entrez symbol
  tmp = sapply(tmp, function(x) seurat_rowname_to_entrez[[x]][1]) %>% 
    na.exclude() %>% unique()
  return(tmp)
})
genesets_down = lapply(cluster_all, function(x) {
  tmp = sc_markers_filt_down %>% 
    dplyr::filter(cluster==x) %>% 
    dplyr::pull(gene)
  # Pick the first matching Entrez symbol
  tmp = sapply(tmp, function(x) seurat_rowname_to_entrez[[x]][1]) %>% 
    na.exclude() %>% unique()
  return(tmp)
})
names(genesets_up) = paste0("DEG_up_cluster_", cluster_all)
names(genesets_down) = paste0("DEG_down_cluster_", cluster_all)
genesets = c(genesets_up, genesets_down)
  
# Loop through gene lists
enriched = list()
for (i in 1:length(genesets)) {
  if (length(genesets[[i]]) >= 3) {
    message("Geneset ", names(genesets)[i])
    enriched[[i]] = enrichR::enrichr(genesets[[i]], databases=param$enrichr_dbs)
  } else { 
    message("Geneset ", names(genesets)[i], " has less than 3 genes; skip enrichr")
    enriched[[i]] = NA
  }
}
names(enriched) = names(genesets)

# Write enrichment results to file
enriched_top = matrix(NA, nrow=0, ncol=6)
colnames(enriched_top) = c("GeneSet", "Database", "Term", "Overlap", "Adjusted_pval", "Genes")
for (i in 1:length(enriched)) { 
  if (!is.null(enriched[[i]])) { 
    openxlsx::write.xlsx(enriched[[i]], file=paste0(param$path_out, "/Functions_", names(enriched)[i], ".xlsx"))
  }
}
```

The following table contains the top enriched term per geneset and datqbase. 
```{r functional_enrichment_results}
for (i in 1:length(enriched)) { 
  if ((!is.null(enriched[[i]])) & (!is.na(enriched[[i]]))) { 

    # Remember top term per geneset
    for(j in 1:length(enriched[[i]])) {
        enriched_top = rbind(enriched_top, 
                             c(names(enriched)[i], 
                             names(enriched[[i]])[j], 
                             enriched[[i]][[j]][1, c("Term", "Overlap", "Adjusted.P.value", "Genes")]))
    }
  }
}

# Print table of top terms per gene set
knitr::kable(enriched_top, align="l", caption="Top enriched term per geneset") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%", height="700px")
```

# Loupe Cell Browser integration
We export the UMAP 2D visualisation, metadata such as the cell clusters, and lists of differentially expressed genes, so you can open and work with these in the Loupe Cell Browser.  
```{r loupe_integration}
# Export UMAP coordinates
loupe_umap = as.data.frame(sc@reductions$umap@cell.embeddings)
loupe_umap$Barcode = gsub(pattern="_", replacement="-", x=rownames(loupe_umap), fixed=TRUE)
if (length(grep(pattern="-$", x=loupe_umap$Barcode, perl=TRUE))==0) loupe_umap$Barcode=paste0(loupe_umap$Barcode, "-1")
loupe_umap = loupe_umap[, c("Barcode", "UMAP_1", "UMAP_2")]
colnames(loupe_umap) = c("Barcode", "UMAP-1", "UMAP-2")
write.table(loupe_umap, file=paste0(param$path_out, "/Seurat2Loupe_Umap.csv"), col.names=TRUE, row.names=FALSE, quote=FALSE, sep=",")

# Export categorical metadata
meta_to_export = c("orig.ident", "seurat_clusters", "Phase")
# if (run.hto) meta.to.export = c(meta.to.export, "HTO_maxID", "HTO_classification", "HTO_classification.global", "hash.ID")
loupe_meta = as.data.frame(sc@meta.data[,meta_to_export])
loupe_meta = cbind(Barcode=gsub(pattern="_", replacement="-", rownames(loupe_meta), fixed=TRUE), loupe_meta)
if (length(grep(pattern="-$", x=loupe_meta$Barcode, perl=TRUE))==0) loupe_meta$Barcode=paste0(loupe_meta$Barcode, "-1")
write.table(x=loupe_meta, file=paste0(param$path_out, "/Seurat2Loupe_metadata.csv"), col.names=TRUE, row.names=FALSE, quote=FALSE, sep=",")

# Export gene sets
loupe_genesets = data.frame(List=paste0("DEG_up_cluster_", sc_markers_filt_up[,"cluster"]), 
                            Name=sc_markers_filt_up[,"gene"], 
                            Ensembl=seurat_rowname_to_ensembl[sc_markers_filt_up[,"gene"]])
loupe_genesets = rbind(loupe_genesets, 
                       data.frame(List=paste0("DEG_down_cluster_", sc_markers_filt_down[,"cluster"]), 
                                  Name=sc_markers_filt_down[,"gene"], 
                                  Ensembl=seurat_rowname_to_ensembl[sc_markers_filt_down[,"gene"]]))

genesets_to_export = list(genes_cc_s_phase=genes_s[,2], genes_cc_g2m_phase=genes_g2m[,2])
for (i in names(genesets_to_export)) {
  tmp_genes = genesets_to_export[[i]]
  tmp_genes = tmp_genes[tmp_genes %in% names(symbol_to_ensembl)]
  loupe_genesets = rbind(loupe_genesets,
                         data.frame(List=i,
                                    Name=tmp_genes,
                                    Ensembl=seurat_rowname_to_ensembl[tmp_genes]))
}

write.table(loupe_genesets, file=paste0(param$path_out, "/Seurat2Loupe_genesets.csv"), col.names=TRUE, row.names=FALSE, quote=FALSE, sep=",")
```

# Output files
All files generated with this report are written into the provided output folder `r param$path_out`: 

* Annotation files  
  + `r paste0(param$mart_dataset, ".annot.csv")`: Table that contains several identifiers and annotation (columns) per gene (rows) (optional)   
* Differentially expressed genes  
  + markers_xlsx: Excel file with one tab per cell cluster  
* Loupe Cell Browser files  
  + Seurat2Loupe_Umap.csv: Seurat UMAP 2D visualisation  
  + Seurat2Loupe_metadata.csv: Seurat cell clusters  
  + Seurat2Loupe_genesets.csv: Seurat differentially expressed genes   
* Functional enrichment of differentially expressed genes per cell cluster  
  + Functions_DEG_down_cluster_1.xlsx, Functions_DEG_up_cluster_1.xlsx, ...: Excel files with one tab per database  
  
```{r save, eval=FALSE}
save.image(paste0(param$path_out, "/Seurat_scAnalysis.RData"))
```

# Software versions
This report was generated using the [scrnaseq](https://github.com/ktrns/scrnaseq) GitHub repository. Software versions were collected at run time. 
```{r versions}
out = scrnaseq_session_info()

knitr::kable(out, align="l") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
```

# References
```{r bib}
knitcitations::write.bibtex(file="references.bib")
```
